package com.babyorm;

import com.babyorm.annotation.ColumnName;
import com.babyorm.annotation.PK;
import com.babyorm.annotation.SchemaName;
import com.babyorm.annotation.TableName;
import com.babyorm.util.ReflectiveUtils;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.babyorm.util.ReflectiveUtils.*;

/**
 * A repo, baby
 * <p>
 * To make a new repo, try one of: new BabyRepo<Foo>(){}; or new BabyRepo<Foo>(Foo.class); or BabyRepo.forType(Foo.class);
 * <p>
 * You must call {@link #setGlobalConnectionSupplier(ConnectionSupplier)} or provide a ConnectionSupplier via Constructor or setter
 * If you don't, shit's gonna throw errors telling you to do this.
 * <p>
 * You may also want to provide a {@link KeyProvider} if your {@link PK} is not autogenerated.
 * we'll remind you if we need to.
 *
 * @param <T> The type of entity this repo likes the most
 */
public class BabyRepo<T> {

    /**
     * the column getter methods on the ResultSet class
     */
    private static final Map<Class<?>, Method> GETTERS =
            addKeySuperTypes(
                    addPrimitivesToMap(
                            findMethods(
                                    ResultSet.class.getMethods(),
                                    Method::getReturnType,
                                    m -> m.getName().startsWith("get"),
                                    m -> !m.getName().startsWith("getN"),
                                    m -> m.getParameterCount() == 1,
                                    m -> m.getParameterTypes()[0].equals(String.class))));

    /**
     * the parameter setter methods on the PreparedStatement class
     */
    private static final Map<Class<?>, Method> SETTERS =
            addKeySuperTypes(
                    addPrimitivesToMap(
                            findMethods(
                                    PreparedStatement.class.getMethods(),
                                    m -> m.getParameterTypes()[1],
                                    m -> m.getName().startsWith("set"),
                                    m -> !m.getName().startsWith("setN"),
                                    m -> m.getParameterCount() == 2,
                                    m -> m.getParameterTypes()[0].equals(Integer.TYPE))));

    private Class<T> entityType;
    private List<Field> fields, nonKeyFields;
    private String baseSql, updateSql, insertSqlNoKey, insertSql, deleteSql;
    private static ConnectionSupplier globalConnectionSupplier;
    private ConnectionSupplier localConnectionSupplier;
    private List<Field> keyFields;
    private KeyProvider keyProvider;
    private List<String> keyFieldNames;
    private Map<Field, String> columnNames;

    /**
     * Pretty straight forward, can't really screw this one up.
     */
    public BabyRepo(Class<T> entityType) {
        init(entityType, null);
    }

    /**
     * @param keyProvider The key provider for the associated entity.
     */
    public BabyRepo(Class<T> entityType, KeyProvider keyProvider) {
        init(entityType, keyProvider);
    }

    /**
     * You MUST extend this class and specify your entity type on the class that directly extends
     * this class. try: new BabyRepo<Foo>(){};
     */
    public BabyRepo() {
        this((KeyProvider) null);
    }

    /**
     * You MUST extend this class and specify your entity type on the class that directly extends
     * this class. try: new BabyRepo<Foo>(){};
     */
    public BabyRepo(KeyProvider keyProvider) {
        Type genericSuperclass = this.getClass().getGenericSuperclass();
        if (genericSuperclass == null || !(genericSuperclass instanceof ParameterizedType)) {
            throw new BabyDBException("You must extend BabyRepo to use the no-arg constructor.");
        }
        init((Class<T>) ((ParameterizedType) genericSuperclass).getActualTypeArguments()[0], keyProvider);
    }

    /**
     * Use a local connection supplier instead of the global connection supplier
     */
    public BabyRepo(ConnectionSupplier connectionSupplier) {
        this();
        this.localConnectionSupplier = connectionSupplier;
    }

    /**
     * Use a local connection supplier instead of the global connection supplier
     */
    public BabyRepo(ConnectionSupplier connectionSupplier, KeyProvider keyProvider) {
        this(keyProvider);
        this.localConnectionSupplier = connectionSupplier;
    }

    /**
     * Use a local connection supplier instead of the global connection supplier
     */
    public BabyRepo(Class<T> entityType, ConnectionSupplier connectionSupplier) {
        this(entityType);
        this.localConnectionSupplier = connectionSupplier;
    }

    /**
     * Use a local connection supplier instead of the global connection supplier
     */
    public BabyRepo(Class<T> entityType, ConnectionSupplier connectionSupplier, KeyProvider keyProvider) {
        this(entityType, keyProvider);
        this.localConnectionSupplier = connectionSupplier;
    }

    /**
     * Factory method to get a new repository
     */
    public static <E> BabyRepo<E> forType(Class<E> type) {
        return new BabyRepo<>(type);
    }

    /**
     * Set the global connection supplier to use across all repositories, probably shouldn't change this at run time,
     * but it's your life, do what you want.
     */
    public static void setGlobalConnectionSupplier(ConnectionSupplier globalConnectionSupplier) {
        BabyRepo.globalConnectionSupplier = globalConnectionSupplier;
    }

    /**
     * Set the connection provider to use for this instance
     */
    public void setLocalConnectionSupplier(ConnectionSupplier localConnectionSupplier) {
        this.localConnectionSupplier = localConnectionSupplier;
    }

    private void init(Class<T> entityType, KeyProvider<T> keyProvider) {
        this.entityType = entityType;
        this.fields = Arrays.asList(this.entityType.getDeclaredFields());
        this.fields.forEach(f -> f.setAccessible(true));
        this.keyFields = findFields(this.entityType, f -> f.getAnnotation(PK.class) != null);
        this.nonKeyFields = findFields(this.entityType, f -> f.getAnnotation(PK.class) == null);
        this.keyFields.forEach(f->f.setAccessible(true));
        this.keyProvider = keyProvider;
        this.keyFieldNames = keyFields.stream().map(Field::getName).collect(Collectors.toList());
        this.columnNames = this.keyFields.stream().collect(Collectors.toMap(f -> f, f -> Optional.ofNullable(f.getAnnotation(ColumnName.class)).map(ColumnName::value).orElseGet(f::getName)));
        boolean isAutogenerated = this.keyFields.stream().map(f->f.getAnnotation(PK.class)).map(PK::autogenerated).reduce(true, (a,b)->a&&b);
        if (!isAutogenerated && keyProvider == null) {
            throw new BabyDBException("You must provide a KeyProvider if your entity's PK is not autogenerated. I forgot too. :|");
        }
        if(this.keyFields.size()> 1){
            Class<?> keyClass = (Class<T>) ((ParameterizedType) keyProvider.getClass().getGenericSuperclass()).getActualTypeArguments()[0];
            if(!keyClass.isAssignableFrom(Map.class)){
                throw new BabyDBException("Your entity has multiple PK columns, but your keyProvider does not return a Map. " +
                        "You must provide a Map<String,Object> of Name to Value mappings");
            }
        }
        buildCachedSqlStatements();
    }

    private void buildCachedSqlStatements() {
        String tableName = determineTableName();

        this.baseSql = "select * from " + tableName;
        this.deleteSql = "delete from " + tableName ;
        this.updateSql = "update " + tableName
                + " set " + nonKeyFields.stream().map(f -> columnNames.get(f) + "=?").collect(Collectors.joining(","));
        this.insertSqlNoKey = "insert into " + tableName
                + "(" + nonKeyFields.stream()
                .map(columnNames::get)
                .collect(Collectors.joining(",")) + ")"
                + " values (" + nonKeyFields.stream().map(f -> "?").collect(Collectors.joining(",")) + ")";
        this.insertSql = "insert into " + tableName
                + "(" + fields.stream()
                .map(columnNames::get)
                .collect(Collectors.joining(",")) + ")"
                + " values (" + fields.stream().map(f -> "?").collect(Collectors.joining(",")) + ")";
    }

    private String determineTableName() {
        String tableName = Optional.ofNullable(this.entityType.getAnnotation(SchemaName.class))
                .map(s -> s.value() + ".")
                .orElse("");
        tableName += Optional.ofNullable(this.entityType.getAnnotation(TableName.class))
                .map(TableName::value)
                .orElseGet(() -> camelCase(entityType.getSimpleName()));
        return tableName;
    }

    private String camelCase(String s) {
        return Character.toLowerCase(s.charAt(0)) + s.substring(1);
    }

    public T get(Object id) {
        return getOneByAll(keyValue(id));
    }

    private Map<String, Object> keyValue(Object id){
        if(keyFields.size()>1){
            try{
                if(!(id instanceof Map)){
                    throw new BabyDBException("You have multiple PKs on your entity. You must provide a Map<String,Object> of Name to Value mappings when querying by id.");
                }
                Map<String, Object> keyValues = (Map) id;
                return keyFields.stream().collect(Collectors.toMap(columnNames::get, f->keyValues.get(columnNames.get(f))));
            } catch (ClassCastException e) {
                throw new BabyDBException("You must provide a Map<String,Object> of Name to Value mappings when querying by id.", e);
            }
        } else {
            return Collections.singletonMap(columnNames.get(keyFields.get(0)), id);
        }
    }

    private Map<String, Object> keyValueFromRecord(T record){
        return this.keyFields.stream().collect(Collectors.toMap(columnNames::get, f->getSafe(f, record)));
    }

    public List<T> getAll() {
        return (List<T>) getSome(null, null, true);
    }

    /**
     * Get one record by a single column value. this is either the database column name or the field name.
     * We'll figure it out.
     *
     * @param field The field name/column name you want to look up the record by.
     * @param value The value you're searching for.
     *              If the value is a collection, an in list will be created.
     * @return The found record if any
     */
    public T getOneBy(String field, Object value) {
        return getOneByAll(Collections.singletonMap(field, value));
    }

    /**
     * Find a single record that matches ALL of the columns
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return The found record, if any
     */
    public T getOneByAll(Map<String, Object> columnValueMap) {
        return (T) getSome(columnValueMap, " AND ", false);
    }

    /**
     * Find a single record that matches ANY of the columns.
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return The found record, if any
     */
    public T getOneByAny(Map<String, Object> columnValueMap) {
        return (T) getSome(columnValueMap, " OR ", false);
    }

    /**
     * Find a many records that match a single column.
     *
     * @param field The field name/column name you want to look up the record by.
     * @param value The value you're searching for.
     *              If the value is a collection, an in list will be created.
     */
    public List<T> getManyBy(String field, Object value) {
        return getManyByAll(Collections.singletonMap(field, value));
    }

    /**
     * Find a many records that match ALL of the columns.
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return The found records, if any
     */
    public List<T> getManyByAll(Map<String, Object> columnValueMap) {
        return (List<T>) getSome(columnValueMap, " AND ", true);
    }

    /**
     * Find a many records that match ANY of the columns.
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return The found records, if any
     */
    public List<T> getManyByAny(Map<String, Object> columnValueMap) {
        return (List<T>) getSome(columnValueMap, " OR ", true);
    }

    //TODO: Handle: Entity has field X but no field with that name was found in result set. Either add a Name annotation, or make sure you selected that field.
    private Object getSome(Map<String, Object> map, String operator, boolean isMany) {
        try (Connection conn = getConnection()) {
            PreparedStatement st;
            String sql = baseSql;
            if (map != null) {
                baseSql += buildWhere(map, operator);
                st = prepare(conn, sql, map.values().toArray());
            } else {
                st = prepare(conn, sql);
            }
            st.execute();
            return mapResultSet(st, isMany);
        } catch (SQLException e) {
            throw new BabyDBException("Failed to execute query", e);
        }

    }

    private String buildWhere(Map<String, Object> map, String operator) {
        return " where " + map.entrySet().stream()
                .map(e -> {
                    String columnName = getField(entityType, e.getKey())
                            .map(columnNames::get)
                            .orElse(e.getKey());

                    if (e.getValue() instanceof Collection) {
                        return columnName + " in (" +
                                ((Collection<?>) e.getValue()).stream()
                                        .map(o -> "?")
                                        .collect(Collectors.joining(",")) + ")";
                    } else {
                        return columnName + "=?";
                    }
                })
                .collect(Collectors.joining(Optional.ofNullable(operator).orElse("")));
    }

    private PreparedStatement prepare(Connection conn, String sql, Object... args) {
        try {
            PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            int[] pos = new int[]{1};
            Arrays.stream(args)
                    .flatMap(o -> o instanceof Collection ? ((Collection) o).stream() : Stream.of(o))
                    .forEach(o -> Optional.ofNullable(SETTERS.get(o.getClass()))
                            .map(s -> invokeSafe(s, ps, pos[0]++, o))
                            .orElseThrow(() -> new BabyDBException("Unsupported property type: " + o.getClass().getCanonicalName()))
                    );
            return ps;
        } catch (SQLException e) {
            throw new BabyDBException("Failed to prepare statement", e);
        }
    }

    private Connection getConnection() {
        if (localConnectionSupplier == null && globalConnectionSupplier == null) {
            throw new BabyDBException("You must set a connection supplier. Didn't read the class javadoc eh?");
        }
        return Optional.ofNullable(localConnectionSupplier)
                .map(ConnectionSupplier::getConnection)
                .orElseGet(globalConnectionSupplier::getConnection);
    }

    private Object mapResultSet(PreparedStatement st, boolean isMany) {
        try {
            ResultSet rs = st.getResultSet();
            List<T> many = isMany ? new ArrayList<>() : null;
            boolean hasOne = false;
            T model = null;
            while (rs.next()) {
                if (hasOne && !isMany) {
                    throw new BabyDBException("Multiple rows found for single row query");
                }
                hasOne = true;
                model = entityType.getConstructor().newInstance();
                for (Field f : fields) {
                    f.set(model, getResultValue(f, rs));
                }
                if (isMany) {
                    many.add(model);
                }
            }
            return isMany ? many : model;
        } catch (ReflectiveOperationException | SQLException e) {
            throw new BabyDBException("Failed to map resultSet to object", e);
        }
    }

    private Object getResultValue(Field field, ResultSet resultSet) {
        Class<?> type = field.getType();
        if (!GETTERS.containsKey(type)) {
            throw new BabyDBException("Unsupported model property type:" + type.getCanonicalName());
        }
        return ReflectiveUtils.invokeSafe(GETTERS.get(type), resultSet, columnNames.get(field));
    }

    /**
     * Insert or update the given record
     *
     * @param record The record to save
     * @return The saved record. The record is retrieved from the database after saving to guarantee generated values are retrieved.
     */
    public T save(T record) {
        Objects.requireNonNull(record, "Can't save a null record");
        Object o = getOneByAll(keyValueFromRecord(record));
        if (o == null) {
            return insert(record);
        } else {
            T saved = get(o);
            return saved != null ? update(record) : insert(record);
        }
    }

    /**
     * Update the given record
     */
    public T update(T record) {
        try (Connection conn = getConnection()) {
            List<Object> values = getFieldValues(record, nonKeyFields);
            String updateSql = this.updateSql + whereKeyStatement(record, keyFieldNames);
            values.addAll(keyFieldNames);
            PreparedStatement st = prepare(conn, updateSql, values.toArray());
            st.executeUpdate();
            return st.getUpdateCount() == 0 ? null : get(keyFields.stream().collect(Collectors.toMap(s->s, s->getSafe(s, record))));
        } catch (SQLException e) {
            throw new BabyDBException("Update failed", e);
        }

    }

    private String whereKeyStatement(T record, List<String> keyFieldNames) {
        return " where " + keyFieldNames.stream().map(f->"=?").collect(Collectors.joining(" AND "))
    }

    /**
     * Insert the given record into the database
     *
     * @param record The record to insert
     */
    public T insert(T record) {
        Objects.requireNonNull(record, "Can't save a null record");
        boolean hasKey = keyFields.stream().map(f->getSafe(f, record) != null).reduce(true, (a,b)->a&&b);
        try (Connection conn = getConnection()) {
            //TODO: fix autogen for multi valued keys
            boolean isAutogen = keyFields.getAnnotation(PK.class).autogenerated();
            Object generatedKey = null;
            if (isAutogen) {
                generatedKey = this.keyProvider.nextKey();
                setSafe(keyFields, record, generatedKey);
            }
            PreparedStatement st = prepare(
                    conn,
                    hasKey || !isAutogen ? insertSql : insertSqlNoKey,
                    getFieldValues(record, hasKey ? fields : nonKeyFields).toArray());
            st.executeUpdate();
            if (hasKey || !isAutogen) {
                return get(isAutogen ? generatedKey : getFieldValues(record, Collections.singletonList(keyFields)).get(0));
            } else {
                ResultSet keys;
                keys = st.getGeneratedKeys();
                if (keys.next()) {
                    return get(getResultValue(keyFields, keys));
                } else {
                    throw new BabyDBException("No key was returned from the db on insert for " + this.entityType.getCanonicalName());
                }
            }
        } catch (SQLException e) {
            throw new BabyDBException("Insert failed", e);
        }
    }

    /**
     * Delete a record by it's {@link PK}
     *
     * @param key The pk of the record to delete
     * @return whether a record was deleted or not
     */
    public boolean deleteByPK(Object key) {
        return deleteByAll(keyValue(key));
    }

    /**
     * Delete a record by it's {@link PK}
     *
     * @param entity The record to delete, the PK will be retrieved and used in the delete statement
     * @return whether a record was deleted or not
     */
    public boolean delete(T entity) {
        return deleteByAll(keyValue(entity));
    }

    /**
     * Delete by a specific column
     *
     * @param field The field/column name to delete by
     * @param value The value to search by
     * @return Whether any records were deleted or not
     */
    public boolean deleteBy(String field, Object value) {
        try (Connection conn = getConnection()) {
            PreparedStatement st = prepare(conn, this.deleteSql + buildWhere(Collections.singletonMap(field, value), null));
            return st.executeUpdate() > 0;
        } catch (SQLException e) {
            throw new BabyDBException("Delete failed", e);
        }
    }

    /**
     * delete records that match ALL of the columns.
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return whether any records were deleted
     */
    public boolean deleteByAll(Map<String, Object> columnValueMap) {
        try (Connection conn = getConnection()) {
            PreparedStatement st = prepare(conn, this.deleteSql + buildWhere(columnValueMap, " OR "));
            return st.executeUpdate() > 0;
        } catch (SQLException e) {
            throw new BabyDBException("Delete failed", e);
        }
    }

    /**
     * delete records that match ANY of the columns.
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return whether any records were deleted
     */
    public boolean deleteByAny(Map<String, Object> columnValueMap) {
        try (Connection conn = getConnection()) {
            PreparedStatement st = prepare(conn, this.deleteSql + buildWhere(columnValueMap, " AND "));
            return st.executeUpdate() > 0;
        } catch (SQLException e) {
            throw new BabyDBException("Delete failed", e);
        }
    }


}